# Note: We usually choose ebc with dynamic volume provision because volume and servers are placed at same location.

* How to create and delete all pods?
```
kubectl apply -f namespace.yaml
```
```
kubectl apply -f expense-ebs-dynamic-sc.yaml
```

```
kubectl apply -f mysql/manifest.yaml
```
```
kubectl apply -f backend/manifest.yaml
```
```
kubectl apply -f frontend/manifest.yaml
```
```
kubectl apply -f debug/manifest.yaml
```

```
kubectl delete pods --all -n your-namespace
```

# How to test or debug mysql data using Debug pod
```
kubectl exec -it debug -n expense -- /bin/bash
```
```
mysql -h mysql -u root -pExpenseApp@1
```



```
kubectl exec -it backend -n expense -- /bin/bash
```
```
ps -ef
```
```
netstat -tlnp
```



* General Kubernetes Basics (must-know)

# List pods
kubectl get pods -n <namespace>

# Describe pod (events, errors)
kubectl describe pod <pod-name> -n <namespace>

# Pod logs
kubectl logs <pod-name> -n <namespace>

# Exec into pod
kubectl exec -it <pod-name> -n <namespace> -- /bin/bash



1Ô∏è‚É£ Check MySQL pod is running
```
kubectl get pods -n expense
```

2Ô∏è‚É£ Check MySQL container logs
```
kubectl logs mysql-pod-name -n expense
```
Look for:
ready for connections
‚ùå crash loops / permission errors

3Ô∏è‚É£ Check MySQL process inside pod
```
kubectl exec -it mysql-pod-name -n expense -- ps -ef | grep MySQL
```

4Ô∏è‚É£ Check MySQL port (3306) inside pod
```
kubectl exec -it mysql-pod-name -n expense -- netstat -lntp
```
# OR
```
kubectl exec -it mysql-pod-name -n expense -- ss -lntp
```

5Ô∏è‚É£ Check MySQL Service (IMPORTANT)
Instead of IP/hostname:
```
kubectl get svc -n expense
```

Example:
mysql   ClusterIP   10.96.10.23   <none>   3306/TCP

6Ô∏è‚É£ Test MySQL connection from another pod
```
kubectl exec -it backend-pod -n expense -- \
mysql -h mysql -u root -pExpenseApp@1
```

üëâ Use service name (mysql), NOT DNS like db.daws78s.online

7Ô∏è‚É£ Check DB data imported
```
kubectl exec -it mysql-pod -n expense -- mysql -u root -pExpenseApp@1
```
```
show databases;
```
```
use transactions;
```
```
show tables;
```
=========================================
üîπ BACKEND ‚Äì Kubernetes Way
1Ô∏è‚É£ Check backend pod
```
kubectl get pods -n expense
```

2Ô∏è‚É£ Check backend logs
```
kubectl logs backend-pod-name -n expense
```

3Ô∏è‚É£ Check backend process
```
kubectl exec -it backend-pod -n expense -- ps -ef | grep backend
```

4Ô∏è‚É£ Check backend port (8080)
```
kubectl exec -it backend-pod -n expense -- netstat -lntp
```

5Ô∏è‚É£ Check backend service
```
kubectl get svc backend -n expense
```

6Ô∏è‚É£ Test MySQL connectivity from backend
```
kubectl exec -it backend-pod -n expense -- telnet mysql 3306
```
OR
```
kubectl exec -it backend-pod -n expense -- nc -zv mysql 3306
```

7Ô∏è‚É£ Ping test (only works if ICMP allowed)
```
kubectl exec -it backend-pod -n expense -- ping -c3 MySQL
```


üîπ FRONTEND ‚Äì Kubernetes Way
1Ô∏è‚É£ Check frontend pod
```
kubectl get pods -n expense
```

2Ô∏è‚É£ Check nginx logs
```
kubectl logs frontend-pod-name -n expense
```

3Ô∏è‚É£ Check nginx process
```
kubectl exec -it frontend-pod -n expense -- ps -ef | grep nginx
```

4Ô∏è‚É£ Check port 80
```
kubectl exec -it frontend-pod -n expense -- netstat -lntp
```

5Ô∏è‚É£ Check frontend service
```
kubectl get svc frontend -n expense
```
If exposed externally:
```
kubectl get svc frontend -n expense -o wide
```

6Ô∏è‚É£ Test backend connectivity from frontend
```
kubectl exec -it frontend-pod -n expense -- telnet backend 8080
```



